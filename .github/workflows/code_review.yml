name: GPT Code Review

on:
  workflow_call:
    inputs:
      base_branch:
        description: 'Base branch to compare against'
        required: true
        type: string
    secrets:
      token:
        description: 'GitHub Token'
        required: true
      secret_url:
        description: 'Ngrok url'
        required: true

  # pull_request:
  #   types: [opened, synchronize, reopened]
  # workflow_dispatch:

jobs:
  code_review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
          token: ${{ secrets.token }}
          secret_url: ${{ secrets.secret_url }}

      - name: Clone Scripts Repository if Empty
        run: |
          if [ ! -d /home/runner/work/code_review_bot/code_review_bot/clone ]; then
            mkdir -p /home/runner/work/code_review_bot/code_review_bot/clone
          fi
          ls -l /home/runner/work/code_review_bot/code_review_bot/clone
          if [ -z "$(ls -A /home/runner/work/code_review_bot/code_review_bot/clone)" ]; then
             git clone https://x-access-token:${{ secrets.token }}@github.com/andreea-ghe/code_review_bot.git /home/runner/work/code_review_bot/code_review_bot/clone
          else
             echo "Directory is not empty, skipping clone"
          fi

      - name: Cache Python Packages
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r /home/runner/work/code_review_bot/code_review_bot/clone/requirements.txt

      - name: Initialize package.json if missing
        run: |
          cd /home/runner/work/code_review_bot/code_review_bot/clone
          if [ ! -f "package.json" ]; then
            npm init -y
          fi
          npm install @octokit/core@latest node-fetch

      - name: Fetch Base Branch
        run: |
          git fetch origin ${{ inputs.base_branch }}:${{ inputs.base_branch }}

      - name: Get Changed Files
        id: changed-files
        uses: tj-actions/changed-files@v34

      - name: List All Changed Files
        run: |
          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            echo "$file was changed"
          done

      - name: Create All Files Directory
        run: mkdir -p all_files

      - name: Copy All Files to Directory
        run: |
          all_files=$(git ls-tree -r HEAD --name-only)
          for file in $all_files; do
            dir_name=$(dirname "$file")
            mkdir -p "all_files/$dir_name"
            cp "$file" "all_files/$file"
          done

      - name: Run Python Script
        env:
          MY_URL: ${{ secrets.secret_url}}
        run: |
          changed_files="${{ steps.changed-files.outputs.all_changed_files }}"
          
          # Filter to only include Python files
          python_files=$(echo "$changed_files" | grep -E '\.py$')
          
          if [ -n "$python_files" ]; then
            # Run pylint on the filtered Python files
            pylint $python_files > reviews.txt || true
            cat reviews.txt
          else
            echo "No Python files to lint."
          fi
          
      - name: Get Latest Commit ID
        id: get_commit
        run: echo "commit_id=$(git rev-parse HEAD)" >> $GITHUB_ENV

      - name: Add Code Suggestions Comments
        env:
          COMMIT_ID: ${{ github.event.pull_request.head.sha }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_NUMBER: ${{ github.event.number }}
          GITHUB_TOKEN: ${{ secrets.token }}
        run: |
          # Use awk to process the file
          
          input_file="reviews.txt"
          declare -A file_reviews
          
          # Read the entire reviews.txt into a variable
          content=$(awk '
          /^\*\*\*\*\*\*\*\*\*\*\*\*\*/ {  # Match lines with exactly 13 asterisks
              file_name = $3
          }
          /^[^\*]/ && file_name {  # Match lines that do not start with asterisks (review lines), and ensure file_name is set
              print "File: " file_name
              print "Review: " $0
          }
          ' "$input_file")
          
          # Process each line of content
          while IFS= read -r line; do
              if [[ $line == File:* ]]; then
                  file_name=$(echo "$line" | cut -d" " -f2)
                  current_file="$file_name"
              elif [[ $line == Review:* ]]; then
                  review=$(echo "$line" | cut -d" " -f2-)
          
                  # Aggregate reviews for each file
                  file_reviews["$current_file"]+="$review\n"
              fi
          done <<< "$content"
          
          # Now post a single comment per file with all aggregated reviews
          for file_name in "${!file_reviews[@]}"; do
              reviews=${file_reviews["$file_name"]}

              formatted_reviews=$(echo -e "$reviews" | sed ':a;N;$!ba;s/\n/\\n/g')
              comment = "__FILE: $file_name__\\n\\n$formatted_reviews"
              
              # Make an API call to post the comment on the PR
              curl -s -X POST -H "Authorization: token ${{ secrets.token }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.number }}/comments \
              -d "{\"body\": $comment}"
          done
        shell: bash
